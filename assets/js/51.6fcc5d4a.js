(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{419:function(t,e,a){"use strict";a.r(e);var s=a(42),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react面试题总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react面试题总结"}},[t._v("#")]),t._v(" React面试题总结")]),t._v(" "),a("h2",{attrs:{id:"react组件如何通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react组件如何通信"}},[t._v("#")]),t._v(" React组件如何通信")]),t._v(" "),a("h2",{attrs:{id:"jsx的本质是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsx的本质是什么"}},[t._v("#")]),t._v(" JSX的本质是什么？")]),t._v(" "),a("p",[t._v("可以同过对比vue的模板编译来讲")]),t._v(" "),a("h2",{attrs:{id:"context是什么-有何用途"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context是什么-有何用途"}},[t._v("#")]),t._v(" context是什么，有何用途？")]),t._v(" "),a("h2",{attrs:{id:"shouldconponentupdate的用途"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shouldconponentupdate的用途"}},[t._v("#")]),t._v(" shouldConponentUpdate的用途")]),t._v(" "),a("h2",{attrs:{id:"描述redux单项数据流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#描述redux单项数据流"}},[t._v("#")]),t._v(" 描述redux单项数据流")]),t._v(" "),a("h2",{attrs:{id:"setstate是同步还是异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setstate是同步还是异步"}},[t._v("#")]),t._v(" setState是同步还是异步？")]),t._v(" "),a("h2",{attrs:{id:"this的绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this的绑定"}},[t._v("#")]),t._v(" this的绑定")]),t._v(" "),a("ol",[a("li",[t._v("可以再constructor中绑定this")]),t._v(" "),a("li",[t._v("使用箭头函数定义函数")])]),t._v(" "),a("h2",{attrs:{id:"event参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event参数"}},[t._v("#")]),t._v(" event参数")]),t._v(" "),a("p",[t._v("event.preventDefault()//阻止默认行为\nevent.stopPropagation()//阻止冒泡")]),t._v(" "),a("ul",[a("li",[t._v("event不是原生的event，我们打印它可以看到，"),a("em",[t._v("proto")]),t._v(".constructor 是syntheticEvent(组合事件)  原生的是MouseEvent\nreact原生event是event.nativeEvent\n原生的currentTarget指向触发的document")])]),t._v(" "),a("ol",[a("li",[t._v("event是SyntheticEvent,模拟出DOM事件的所有能力")]),t._v(" "),a("li",[t._v("event.navtiveEvent是原生事件")]),t._v(" "),a("li",[t._v("所有的事件都被挂载到document上")]),t._v(" "),a("li",[t._v("和DOM事件不一样，和vue事件也不一样")])]),t._v(" "),a("h2",{attrs:{id:"受控组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#受控组件"}},[t._v("#")]),t._v(" 受控组件")]),t._v(" "),a("h2",{attrs:{id:"setstate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setstate"}},[t._v("#")]),t._v(" setState")]),t._v(" "),a("p",[t._v("不可变值")]),t._v(" "),a("h3",{attrs:{id:"setstate可能是异步更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setstate可能是异步更新"}},[t._v("#")]),t._v(" setState可能是异步更新")]),t._v(" "),a("ul",[a("li",[t._v("直接使用setState后还需要异步渲染，如果在ssetState之后立马拿值只能拿到更新前的值，要拿到值怎么办呢？我们可以在setState中添加第二个参数，设置一个回调来用，vue $nexttick。")]),t._v(" "),a("li",[t._v("setTimeout中调用又是同步的")]),t._v(" "),a("li",[t._v("自己定义的DOM事件，也是同步的")])]),t._v(" "),a("h3",{attrs:{id:"setstate会被合并"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setstate会被合并"}},[t._v("#")]),t._v(" setState会被合并")]),t._v(" "),a("ul",[a("li",[t._v("类似")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  count"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  count"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("这种会被合并，Object.assign({count: this.state.count + 1},{count: this.state.count + 1})")]),t._v(" "),a("ul",[a("li",[t._v("setState中传入函数不能被合并，函数是可执行的，会被立马执行")])]),t._v(" "),a("h2",{attrs:{id:"组件生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件生命周期"}},[t._v("#")]),t._v(" 组件生命周期")]),t._v(" "),a("ul",[a("li",[t._v("挂载时：\n初始化constructor\n渲染 render"),a("br"),t._v("\ncomponentDidMount -> vue mounted  一般ajax就放在这个阶段请求")]),t._v(" "),a("li",[t._v("更新时\nshouldComponentUpdate 我们可以控制它在更新后是否要继续渲染\nrender\ncomponentDidUpdate")]),t._v(" "),a("li",[t._v("卸载时\ncomponentWillUnmount 可以在这里卸载自定义事件，定时器之类的  -> vue beforeDestroy")])]),t._v(" "),a("h2",{attrs:{id:"ref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ref"}},[t._v("#")]),t._v(" ref")]),t._v(" "),a("p",[t._v("react中的ref是用React.createRef()创建出来，\n如 this.nameInputRef = React.createRef(),然后在组件中就可以"),a("input",{ref:"{this.nameInputRef}",attrs:{defaultValue:"{this.state.name}"}})]),t._v(" "),a("h2",{attrs:{id:"非受控组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#非受控组件"}},[t._v("#")]),t._v(" 非受控组件")]),t._v(" "),a("p",[t._v("必须手动操作DOM元素的，setState实现不了\n例如文件上传"),a("input",{attrs:{type:"file"}}),t._v(",富文本编辑器")]),t._v(" "),a("h2",{attrs:{id:"portals-传送门"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#portals-传送门"}},[t._v("#")]),t._v(" Portals(传送门)")]),t._v(" "),a("p",[t._v("组件默认会按照既定层次嵌套渲染")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("如何让组件渲染到父组件以外？\n例如fixed定位的盒子，最好放在最外层，但是他又是个嵌套组件，怎么办？可以使用ReactDOM.creactPortal(html,渲染位置DOM节点)")])]),t._v(" "),a("li",[a("p",[t._v("使用场景")])])]),t._v(" "),a("ol",[a("li",[t._v("父组件设置了overflow:hidden")]),t._v(" "),a("li",[t._v("父组件z-index太小")]),t._v(" "),a("li",[t._v("fixed需要放在body第一层")])]),t._v(" "),a("h2",{attrs:{id:"vdom和diff算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vdom和diff算法"}},[t._v("#")]),t._v(" vdom和diff算法")]),t._v(" "),a("p",[t._v("ceateElement创建一个虚拟dom，ceateElement(type,props,children)\n然后通过render函数，第一步创建一个child节点，通过for in 遍历dom，通过key和setArrt去做相关节点的属性的设置\nsetArrt(node,key,dom.props[key])-> switch(key) 去做相应的属性设置\nobj.foreach() -> 判断是否是虚拟dom 如果是就递归render，如果不是就创建真实节点，并插入到child中\nrenderDom(el,target) 实际使用就像 renderDom(el, document.getElementById('root')")]),t._v(" "),a("ul",[a("li",[t._v("diff算法\n首先就是用一个patch对象记录补丁，调用写好的walk函数，walk(oldTree, newTree, index, patches);\nwalk函数就是先创建一个current记录数组，判断是否又新节点：\n"),a("ul",[a("li",[t._v("没有if(!newNode) -> current.push ->  type:REMOVE")]),t._v(" "),a("li",[t._v("判断是否是文本，是就判断文本值是否改变，current.push -> type: text + newNode")]),t._v(" "),a("li",[t._v("判断属性是否改变 调用diffAttr\n"),a("ul",[a("li",[t._v("diffAttr 就是返回小补丁patch -> for..in 改变和新增的放入补丁\n把属性改变放入current记录，判断是否有子结点，有就做walk")])])]),t._v(" "),a("li",[t._v("有新节点替换，current.push-> type: replace+ newNode")]),t._v(" "),a("li",[t._v("把current给到patch")])])])]),t._v(" "),a("h2",{attrs:{id:"context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[t._v("#")]),t._v(" context")]),t._v(" "),a("p",[t._v("公共信息(语言，主题)的传递传递到每个组件\n用props太繁琐\n用redux小题大做")]),t._v(" "),a("p",[t._v("创建一个context对象，最外层通过context.Provider来生产这个数据，class子组件怎么消费数据呢？子组件名.contextType = Context, 就可以使用this.context,React会往上找最近的Provider。\n函数组件没有实例，子组件名.contextType = Context后，可以直接用子组件名.Consumer")]),t._v(" "),a("h2",{attrs:{id:"异步加载组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步加载组件"}},[t._v("#")]),t._v(" 异步加载组件")]),t._v(" "),a("p",[t._v("vue 中import\nreact React.lazy\nreact React.Suspense")]),t._v(" "),a("h2",{attrs:{id:"性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[t._v("#")]),t._v(" 性能优化")]),t._v(" "),a("ul",[a("li",[t._v("shouldComponentUpdate")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("shouldComponentUpdate")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("nextProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nextState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nextState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//可以渲染")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 不重复渲染")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"为什么scu可定制化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么scu可定制化"}},[t._v("#")]),t._v(" 为什么scu可定制化")]),t._v(" "),a("p",[t._v("因为父组件更新了，子组件也会无条件更新，即使子组件没发生变化，scu返回值默认为true，所以有的就需要自己选择")]),t._v(" "),a("ul",[a("li",[t._v("PureComponent 和 React.memo\nPureComponent,SCU中实现了浅比较\nmemo，函数组件中的PureComponetent")]),t._v(" "),a("li",[t._v("不可变值immutable.js")])]),t._v(" "),a("p",[t._v("及时销毁不用的函数，避免内存泄露\n异步加载组件")])])}),[],!1,null,null,null);e.default=n.exports}}]);